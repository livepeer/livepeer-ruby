# Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'sorbet-runtime'
require 'faraday'

module Livepeer
  module Shared
    # RecordingStatus - Status of the recording process of this stream session.
    class RecordingStatus < T::Enum
      enums do
        WAITING = new('waiting')
        READY = new('ready')
        NONE = new('none')
      end
    end



    class Session < Livepeer::Utils::FieldAugmented
      extend T::Sig


      field :name, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('name') } }
      # Timestamp (in milliseconds) at which the stream object was created
      field :created_at, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('createdAt') } }

      field :id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('id') } }
      # Rate at which sourceBytes increases (bytes/second)
      field :ingest_rate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('ingestRate') } }
      # Indicates whether the stream is healthy or not.
      field :is_healthy, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('isHealthy') } }
      # A string array of human-readable errors describing issues affecting
      # the stream, if any.
      # 
      field :issues, T.nilable(T::Array[String]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('issues') } }

      field :last_seen, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('lastSeen') } }
      # URL for the stream session recording packaged in an mp4.
      field :mp4_url, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('mp4Url') } }
      # Rate at which transcodedBytes increases (bytes/second)
      field :outgoing_rate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('outgoingRate') } }
      # Points to the parent stream object
      field :parent_id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('parentId') } }
      # Used to form the playback URL
      field :playback_id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackId') } }

      field :profiles, T.nilable(T::Array[Shared::FfmpegProfile]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('profiles') } }
      # Should this stream be recorded? Uses default settings. For more
      # customization, create and configure an object store.
      # 
      field :record, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('record') } }
      # Status of the recording process of this stream session.
      field :recording_status, T.nilable(Shared::RecordingStatus), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('recordingStatus'), 'decoder': Utils.enum_from_string(Shared::RecordingStatus, true) } }
      # URL for accessing the recording of this stream session.
      field :recording_url, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('recordingUrl') } }

      field :source_bytes, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceBytes') } }

      field :source_segments, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceSegments') } }
      # Duration of all the source segments, sec
      field :source_segments_duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceSegmentsDuration') } }

      field :transcoded_bytes, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedBytes') } }

      field :transcoded_segments, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedSegments') } }
      # Duration of all the transcoded segments, sec
      field :transcoded_segments_duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedSegmentsDuration') } }


      sig { params(name: String, created_at: T.nilable(Float), id: T.nilable(String), ingest_rate: T.nilable(Float), is_healthy: T.nilable(T::Boolean), issues: T.nilable(T::Array[String]), last_seen: T.nilable(Float), mp4_url: T.nilable(String), outgoing_rate: T.nilable(Float), parent_id: T.nilable(String), playback_id: T.nilable(String), profiles: T.nilable(T::Array[Shared::FfmpegProfile]), record: T.nilable(T::Boolean), recording_status: T.nilable(Shared::RecordingStatus), recording_url: T.nilable(String), source_bytes: T.nilable(Float), source_segments: T.nilable(Float), source_segments_duration: T.nilable(Float), transcoded_bytes: T.nilable(Float), transcoded_segments: T.nilable(Float), transcoded_segments_duration: T.nilable(Float)).void }
      def initialize(name: nil, created_at: nil, id: nil, ingest_rate: nil, is_healthy: nil, issues: nil, last_seen: nil, mp4_url: nil, outgoing_rate: nil, parent_id: nil, playback_id: nil, profiles: nil, record: nil, recording_status: nil, recording_url: nil, source_bytes: nil, source_segments: nil, source_segments_duration: nil, transcoded_bytes: nil, transcoded_segments: nil, transcoded_segments_duration: nil)
        @name = name
        @created_at = created_at
        @id = id
        @ingest_rate = ingest_rate
        @is_healthy = is_healthy
        @issues = issues
        @last_seen = last_seen
        @mp4_url = mp4_url
        @outgoing_rate = outgoing_rate
        @parent_id = parent_id
        @playback_id = playback_id
        @profiles = profiles
        @record = record
        @recording_status = recording_status
        @recording_url = recording_url
        @source_bytes = source_bytes
        @source_segments = source_segments
        @source_segments_duration = source_segments_duration
        @transcoded_bytes = transcoded_bytes
        @transcoded_segments = transcoded_segments
        @transcoded_segments_duration = transcoded_segments_duration
      end
    end
  end
end
