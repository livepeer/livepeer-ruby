# Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'sorbet-runtime'
require 'faraday'
require_relative '../shared/playback_policy'

module Livepeer
  module Shared

    class StreamTargets < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Name of the transcoding profile that should be sent. Use
      # "source" for pushing the source stream data
      # 
      field :profile, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('profile') } }
      # ID of the multistream target object where to push this stream
      field :id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('id') } }
      # If true, the stream audio will be muted, and only silent
      # video will be pushed to the target.
      # 
      field :video_only, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('videoOnly') } }


      sig { params(profile: String, id: T.nilable(String), video_only: T.nilable(T::Boolean)).void }
      def initialize(profile: nil, id: nil, video_only: nil)
        @profile = profile
        @id = id
        @video_only = video_only
      end
    end


    class StreamMultistream < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # References to targets where this stream will be simultaneously
      # streamed to
      # 
      field :targets, T.nilable(T::Array[Shared::StreamTargets]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('targets') } }


      sig { params(targets: T.nilable(T::Array[Shared::StreamTargets])).void }
      def initialize(targets: nil)
        @targets = targets
      end
    end


    class Stream < Livepeer::Utils::FieldAugmented
      extend T::Sig


      field :name, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('name') } }
      # Timestamp (in milliseconds) at which the stream object was created
      field :created_at, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('createdAt') } }
      # Name of the token used to create this object
      field :created_by_token_name, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('createdByTokenName') } }

      field :creator_id, T.nilable(Object), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('creatorId') } }

      field :id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('id') } }
      # Rate at which sourceBytes increases (bytes/second)
      field :ingest_rate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('ingestRate') } }
      # If currently active
      field :is_active, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('isActive') } }
      # Indicates whether the stream is healthy or not.
      field :is_healthy, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('isHealthy') } }
      # A string array of human-readable errors describing issues affecting
      # the stream, if any.
      # 
      field :issues, T.nilable(T::Array[String]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('issues') } }

      field :last_seen, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('lastSeen') } }

      field :multistream, T.nilable(Shared::StreamMultistream), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('multistream') } }
      # Rate at which transcodedBytes increases (bytes/second)
      field :outgoing_rate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('outgoingRate') } }
      # Points to the parent stream object
      field :parent_id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('parentId') } }
      # Used to form playback URL
      field :playback_id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackId') } }
      # Whether the playback policy for a asset or stream is public or signed
      field :playback_policy, T.nilable(Shared::PlaybackPolicy), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackPolicy') } }

      field :profiles, T.nilable(T::Array[Shared::FfmpegProfile]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('profiles') } }
      # Should this stream be recorded? Uses default settings. For more
      # customization, create and configure an object store.
      # 
      field :record, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('record') } }

      field :source_bytes, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceBytes') } }

      field :source_segments, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceSegments') } }
      # Duration of all the source segments, sec
      field :source_segments_duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sourceSegmentsDuration') } }
      # Used to form the RTMP ingest URL
      field :stream_key, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('streamKey') } }
      # If currently suspended
      field :suspended, T.nilable(T::Boolean), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('suspended') } }

      field :transcoded_bytes, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedBytes') } }

      field :transcoded_segments, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedSegments') } }
      # Duration of all the transcoded segments, sec
      field :transcoded_segments_duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('transcodedSegmentsDuration') } }


      sig { params(name: String, created_at: T.nilable(Float), created_by_token_name: T.nilable(String), creator_id: T.nilable(Object), id: T.nilable(String), ingest_rate: T.nilable(Float), is_active: T.nilable(T::Boolean), is_healthy: T.nilable(T::Boolean), issues: T.nilable(T::Array[String]), last_seen: T.nilable(Float), multistream: T.nilable(Shared::StreamMultistream), outgoing_rate: T.nilable(Float), parent_id: T.nilable(String), playback_id: T.nilable(String), playback_policy: T.nilable(Shared::PlaybackPolicy), profiles: T.nilable(T::Array[Shared::FfmpegProfile]), record: T.nilable(T::Boolean), source_bytes: T.nilable(Float), source_segments: T.nilable(Float), source_segments_duration: T.nilable(Float), stream_key: T.nilable(String), suspended: T.nilable(T::Boolean), transcoded_bytes: T.nilable(Float), transcoded_segments: T.nilable(Float), transcoded_segments_duration: T.nilable(Float)).void }
      def initialize(name: nil, created_at: nil, created_by_token_name: nil, creator_id: nil, id: nil, ingest_rate: nil, is_active: nil, is_healthy: nil, issues: nil, last_seen: nil, multistream: nil, outgoing_rate: nil, parent_id: nil, playback_id: nil, playback_policy: nil, profiles: nil, record: nil, source_bytes: nil, source_segments: nil, source_segments_duration: nil, stream_key: nil, suspended: nil, transcoded_bytes: nil, transcoded_segments: nil, transcoded_segments_duration: nil)
        @name = name
        @created_at = created_at
        @created_by_token_name = created_by_token_name
        @creator_id = creator_id
        @id = id
        @ingest_rate = ingest_rate
        @is_active = is_active
        @is_healthy = is_healthy
        @issues = issues
        @last_seen = last_seen
        @multistream = multistream
        @outgoing_rate = outgoing_rate
        @parent_id = parent_id
        @playback_id = playback_id
        @playback_policy = playback_policy
        @profiles = profiles
        @record = record
        @source_bytes = source_bytes
        @source_segments = source_segments
        @source_segments_duration = source_segments_duration
        @stream_key = stream_key
        @suspended = suspended
        @transcoded_bytes = transcoded_bytes
        @transcoded_segments = transcoded_segments
        @transcoded_segments_duration = transcoded_segments_duration
      end
    end
  end
end
