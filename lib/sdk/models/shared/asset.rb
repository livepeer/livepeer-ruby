# Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'sorbet-runtime'
require 'faraday'
require_relative '../shared/ipfs_file_info'
require_relative '../shared/storage_status'
require_relative '../shared/playback_policy'

module Livepeer
  module Shared
    # AssetType - Type of the asset.
    class AssetType < T::Enum
      enums do
        VIDEO = new('video')
        AUDIO = new('audio')
      end
    end


    # NftMetadataTemplate - Name of the NFT metadata template to export. 'player'
    # will embed the Livepeer Player on the NFT while 'file'
    # will reference only the immutable MP4 files.
    # 
    class NftMetadataTemplate < T::Enum
      enums do
        FILE = new('file')
        PLAYER = new('player')
      end
    end


    # Additional data to add to the NFT metadata exported to
    # IPFS. Will be deep merged with the default metadata
    # exported.
    # 
    class NftMetadata < Livepeer::Utils::FieldAugmented
      extend T::Sig



      
      def initialize; end
    end


    class AssetSpec < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Additional data to add to the NFT metadata exported to
      # IPFS. Will be deep merged with the default metadata
      # exported.
      # 
      field :nft_metadata, T.nilable(Shared::NftMetadata), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('nftMetadata') } }
      # Name of the NFT metadata template to export. 'player'
      # will embed the Livepeer Player on the NFT while 'file'
      # will reference only the immutable MP4 files.
      # 
      field :nft_metadata_template, T.nilable(Shared::NftMetadataTemplate), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('nftMetadataTemplate'), 'decoder': Utils.enum_from_string(Shared::NftMetadataTemplate, true) } }


      sig { params(nft_metadata: T.nilable(Shared::NftMetadata), nft_metadata_template: T.nilable(Shared::NftMetadataTemplate)).void }
      def initialize(nft_metadata: nil, nft_metadata_template: nil)
        @nft_metadata = nft_metadata
        @nft_metadata_template = nft_metadata_template
      end
    end


    class Ipfs < Livepeer::Utils::FieldAugmented
      extend T::Sig


      field :dollar_ref, T.nilable(Object), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('$ref') } }

      field :nft_metadata, T.nilable(Shared::IpfsFileInfo), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('nftMetadata') } }

      field :spec, T.nilable(Shared::AssetSpec), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('spec') } }
      # Timestamp (in milliseconds) at which IPFS export task was
      # updated
      # 
      field :updated_at, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('updatedAt') } }


      sig { params(dollar_ref: T.nilable(Object), nft_metadata: T.nilable(Shared::IpfsFileInfo), spec: T.nilable(Shared::AssetSpec), updated_at: T.nilable(Float)).void }
      def initialize(dollar_ref: nil, nft_metadata: nil, spec: nil, updated_at: nil)
        @dollar_ref = dollar_ref
        @nft_metadata = nft_metadata
        @spec = spec
        @updated_at = updated_at
      end
    end


    class AssetStorage < Livepeer::Utils::FieldAugmented
      extend T::Sig


      field :ipfs, T.nilable(Shared::Ipfs), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('ipfs') } }

      field :status, T.nilable(Shared::StorageStatus), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('status') } }


      sig { params(ipfs: T.nilable(Shared::Ipfs), status: T.nilable(Shared::StorageStatus)).void }
      def initialize(ipfs: nil, status: nil)
        @ipfs = ipfs
        @status = status
      end
    end

    # AssetPhase - Phase of the asset
    class AssetPhase < T::Enum
      enums do
        UPLOADING = new('uploading')
        WAITING = new('waiting')
        PROCESSING = new('processing')
        READY = new('ready')
        FAILED = new('failed')
      end
    end


    # Status of the asset
    class AssetStatus < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Phase of the asset
      field :phase, Shared::AssetPhase, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('phase'), 'decoder': Utils.enum_from_string(Shared::AssetPhase, false) } }
      # Timestamp (in milliseconds) at which the asset was last updated
      field :updated_at, Float, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('updatedAt') } }
      # Error message if the asset creation failed.
      field :error_message, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('errorMessage') } }
      # Current progress of the task creating this asset.
      field :progress, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('progress') } }


      sig { params(phase: Shared::AssetPhase, updated_at: Float, error_message: T.nilable(String), progress: T.nilable(Float)).void }
      def initialize(phase: nil, updated_at: nil, error_message: nil, progress: nil)
        @phase = phase
        @updated_at = updated_at
        @error_message = error_message
        @progress = progress
      end
    end


    class Hash < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Hash algorithm used to compute the hash
      field :algorithm, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('algorithm') } }
      # Hash of the asset
      field :hash, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('hash') } }


      sig { params(algorithm: T.nilable(String), hash: T.nilable(String)).void }
      def initialize(algorithm: nil, hash: nil)
        @algorithm = algorithm
        @hash = hash
      end
    end

    # AssetSchemasType - type of track
    class AssetSchemasType < T::Enum
      enums do
        VIDEO = new('video')
        AUDIO = new('audio')
      end
    end



    class Tracks < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Codec of the track
      field :codec, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('codec') } }
      # type of track
      field :type, Shared::AssetSchemasType, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('type'), 'decoder': Utils.enum_from_string(Shared::AssetSchemasType, false) } }
      # Bit depth of the track - only for audio tracks
      field :bit_depth, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('bitDepth') } }
      # Bitrate of the track in bits per second
      field :bitrate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('bitrate') } }
      # Amount of audio channels in the track
      field :channels, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('channels') } }
      # Duration of the track in seconds
      field :duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('duration') } }
      # Frame rate of the track - only for video tracks
      field :fps, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('fps') } }
      # Height of the track - only for video tracks
      field :height, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('height') } }
      # Pixel format of the track - only for video tracks
      field :pixel_format, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('pixelFormat') } }
      # Sample rate of the track in samples per second - only for
      # audio tracks
      # 
      field :sample_rate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('sampleRate') } }
      # Start time of the track in seconds
      field :start_time, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('startTime') } }
      # Width of the track - only for video tracks
      field :width, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('width') } }


      sig { params(codec: String, type: Shared::AssetSchemasType, bit_depth: T.nilable(Float), bitrate: T.nilable(Float), channels: T.nilable(Float), duration: T.nilable(Float), fps: T.nilable(Float), height: T.nilable(Float), pixel_format: T.nilable(String), sample_rate: T.nilable(Float), start_time: T.nilable(Float), width: T.nilable(Float)).void }
      def initialize(codec: nil, type: nil, bit_depth: nil, bitrate: nil, channels: nil, duration: nil, fps: nil, height: nil, pixel_format: nil, sample_rate: nil, start_time: nil, width: nil)
        @codec = codec
        @type = type
        @bit_depth = bit_depth
        @bitrate = bitrate
        @channels = channels
        @duration = duration
        @fps = fps
        @height = height
        @pixel_format = pixel_format
        @sample_rate = sample_rate
        @start_time = start_time
        @width = width
      end
    end

    # Video metadata
    class VideoSpec < Livepeer::Utils::FieldAugmented
      extend T::Sig

      # Bitrate of the video in bits per second
      field :bitrate, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('bitrate') } }
      # Duration of the asset in seconds (float)
      field :duration, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('duration') } }
      # Format of the asset
      field :format, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('format') } }
      # List of tracks associated with the asset when the format
      # contemplates them (e.g. mp4)
      # 
      field :tracks, T.nilable(T::Array[Shared::Tracks]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('tracks') } }


      sig { params(bitrate: T.nilable(Float), duration: T.nilable(Float), format: T.nilable(String), tracks: T.nilable(T::Array[Shared::Tracks])).void }
      def initialize(bitrate: nil, duration: nil, format: nil, tracks: nil)
        @bitrate = bitrate
        @duration = duration
        @format = format
        @tracks = tracks
      end
    end


    class Asset < Livepeer::Utils::FieldAugmented
      extend T::Sig


      field :id, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('id') } }
      # Name of the asset. This is not necessarily the filename, can be a
      # custom name or title
      # 
      field :name, String, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('name') } }

      field :source, Object, { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('source') } }
      # Timestamp (in milliseconds) at which asset was created
      field :created_at, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('createdAt') } }

      field :creator_id, T.nilable(Object), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('creatorId') } }
      # URL to manually download the asset if desired
      field :download_url, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('downloadUrl') } }
      # Hash of the asset
      field :hash, T.nilable(T::Array[Shared::Hash]), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('hash') } }
      # Used to form playback URL and storage folder
      field :playback_id, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackId') } }
      # Whether the playback policy for a asset or stream is public or signed
      field :playback_policy, T.nilable(Shared::PlaybackPolicy), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackPolicy') } }
      # URL for HLS playback
      field :playback_url, T.nilable(String), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('playbackUrl') } }
      # Size of the asset in bytes
      field :size, T.nilable(Float), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('size') } }
      # Status of the asset
      field :status, T.nilable(Shared::AssetStatus), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('status') } }

      field :storage, T.nilable(Shared::AssetStorage), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('storage') } }
      # Type of the asset.
      field :type, T.nilable(Shared::AssetType), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('type'), 'decoder': Utils.enum_from_string(Shared::AssetType, true) } }
      # Video metadata
      field :video_spec, T.nilable(Shared::VideoSpec), { 'format_json': { 'letter_case': OpenApiSDK::Utils.field_name('videoSpec') } }


      sig { params(id: String, name: String, source: Object, created_at: T.nilable(Float), creator_id: T.nilable(Object), download_url: T.nilable(String), hash: T.nilable(T::Array[Shared::Hash]), playback_id: T.nilable(String), playback_policy: T.nilable(Shared::PlaybackPolicy), playback_url: T.nilable(String), size: T.nilable(Float), status: T.nilable(Shared::AssetStatus), storage: T.nilable(Shared::AssetStorage), type: T.nilable(Shared::AssetType), video_spec: T.nilable(Shared::VideoSpec)).void }
      def initialize(id: nil, name: nil, source: nil, created_at: nil, creator_id: nil, download_url: nil, hash: nil, playback_id: nil, playback_policy: nil, playback_url: nil, size: nil, status: nil, storage: nil, type: nil, video_spec: nil)
        @id = id
        @name = name
        @source = source
        @created_at = created_at
        @creator_id = creator_id
        @download_url = download_url
        @hash = hash
        @playback_id = playback_id
        @playback_policy = playback_policy
        @playback_url = playback_url
        @size = size
        @status = status
        @storage = storage
        @type = type
        @video_spec = video_spec
      end
    end
  end
end
